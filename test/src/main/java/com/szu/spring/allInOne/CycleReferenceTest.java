package com.szu.spring.allInOne;

import org.springframework.context.support.ClassPathXmlApplicationContext;
/*
 * 解决循环依赖问题！
 * 提前暴露！
 * 为啥我们要把对象实例化和初始化分清，因为实例化只是为当前对象的完成了创建工作，值也都是默认值，
 * 当初始化的时候才进行赋值操作。
 * 但是循环依赖不会在实例化时发生。
 *
 * 赋值的时候，值的类型可能是引用类型，如果引用对象已经创建，就可以直接从容器中获取，如果没有创建，就还需要中断去创建另外的对象，
 * 但是如果依赖的对象还在依赖当前对象，当前对象没有创建，就产生了循环依赖问题
 *
 * 如何解决循环依赖问题呢？
 * 因为实例化和初始化时分开的，当完成实例化之后就可以让其他对象引用当前对象，只不过这个对象暂时还是一个没有任何属性值填充而已，
 * 后续仍需要对此对象进行剩余的操作。其实就是获取半成品的对象地址，保证对象能被找到，而对象在对空间中是否设置属性值，完全可以在之后进行操作
 *
 *
 * ==================================================================================================================================
 * ==================================================================================================================================
 * ==================================================================================================================================
 * 获取完成对象的时候分为两个步骤，实例化和初始化！ 初始化环节的填充属性不会改变对象的地址空间
 * 但是我们需要考虑的事：Spring在使用时会配置AOP，需要生成具体的代理对象，
 *
 * 1.然而在生成代理对象之前需要先生成普通对象。（因为就算是配置了AOP，AOP也是一个Bean，也需要走完上述的createBeanInstance那个方法流程）
 * 2.所以我们无法确定什么时候获取哪个具体的对象（包括代理对象和普通对象）
 * 3.而且在Spring中有可能同时存在一个BeanName对应普通对象和代理对象两个的情况，当用beanName获取Bean时当然不能两个对象全部获取到，
 * 		所以可以考虑使用分类存储。即：把普通对象和代理对象分别缓存起来。
 * 4.那这两个缓存我优先获取哪个呢？ 其实可以只获取代理对象，因为代理对象包含了普通对象的所有功能，如果一个对象需要被代理
 * 		那么此时普通对象就可以不存在了，只需要代理对象就可以了
 * 		既然代理包含了普通对象所有的功能，在后续创建了代理对象之后，普通对象可以直接被覆盖掉，普通对象存在的必要都没有了！！！
 *
 * 回到 2 中，什么时候获取对象呢？
 * 我们在获取对象的时候，如果检测到当前对象需要被代理，那么直接创建代理对象对其进行覆盖
 * 那么我怎么又能够在随时需要的时候创建代理对象呢？
 * 我们可以传递一个生成代理对象的匿名内部类，当需要获取代理对象的时候，直接调用匿名内部类（现在匿名内部类的主要表达方式变成了Lambda表达式）来生成
 * 		代理对象，类似于回调机制！！！！！！
 *
 *
 * ------------------------------------------------------------------------------------------------------------------------
 * ------------------------------------------------------------------------------------------------------------------------
 * 一二三级缓存中大体内容一览：
 *
 * 一级缓存 singletonObjects ---------> 保存成品对象（普通对象 + 代理对象），方便之后直接获取                key：BeanName -> value：Object
 * 二级缓存 earlySingletonObjects ----> 保存半成品对象（刚刚进行实例化但还没初始化的对象），方便解决循环依赖    key：BeanName -> value：Object
 * 三级缓存 singletonFactories -------> 保存生成代理对象的 lambda 表达式                                key：BeanName -> value：lambda
 *
 * 所以二级缓存解决了循环依赖，它让对象得到了提前暴露 ！！！
 * 三个缓存的对象查找顺序就是从 一级缓存 -> 二级缓存 -> 三级缓存
 * 那么三级缓存 可以 不经过 二级缓存 直接到 一级缓存吗？
 * 答案当然是肯定的！
 *
 * 其实二级缓存来解决循环依赖问题已经完全足够了，三级缓存的意义就在于代理对象创建，如果没有代理对象，二级缓存足以解决问题
 * ------------------------------------------------------------------------------------------------------------------------
 * ------------------------------------------------------------------------------------------------------------------------
 *
 * 5.初始化包含哪些环节：
 * 		a:填充属性
 * 		b:执行Aware接口对应的方法
 * 		c:执行BeanPostProcessor的before方法
 * 		d:执行init-method
 * 		e:执行BeanPostProcessor的after方法
 * 上述步骤完成之后为了获取到一个完整的成品对象，但是在初始化之前我们能确定哪一个对象需要生成代理对象吗？
 * 答案是否定的。但是三级缓存只是一个回调机制，我们可以把所有bean的创建代理对象的lambda表达式放在里边，
 * 在后续如果需要的时候直接调用三级缓存中的 lambda。如果不需要之后可以把三级缓存中的lambda清除掉，
 * 清除的时机是在往一级缓存中放成品对象的时候！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
 *
 * 6.我在什么时候需要生成具体的代理对象呢？
 *
 * 		a: 在进行属性注入的时候，获取该对象的引用对象时候检测注入的引用属性是否需要被代理，如果需要直接创建代理对象
 * 				比如：A有B对象的引用，给A对象进行属性注入的时候，发现B对象需要被代理，此时就可以直接创建B对象的代理对象
 *
 * 		b: 在整个过程中，没有其他对象依赖当前对象，那么可以在最终生成完整对象之前生成代理对象即可，
 * 		   其实就是可以在执行BeanPostProcessor的after方法 时生成代理对象！
 * ==================================================================================================================================
 * ==================================================================================================================================
 * ==================================================================================================================================
 *
 * 所以此处要分为两种情况：构造器 和 set方式
 * 如果是构造器方式创建对象的时候就已经产生了循环依赖，我们没有办法解决。
 * 如果是set方式就可以解决循环依赖问题，因为我们把对象创建和赋值分开了
 *
 * 提前暴露 ！！！ 就是 只完成了实例化 还没完成初始化，后续的时候在为其补充对应的属性值
 * */

/* 判断当前 bean 是否需要提前暴露：单例 && 允许循环依赖 && 当前 Bean正在创建过程中，  检测循环依赖 */
public class CycleReferenceTest {
	public static void main(String[] args) {
		ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext("cycle.xml");
		System.out.println();
	}
}

/*
*	此时已经创建好了 一个A对象的半成品，只申请了空间但是都是默认值的半成品
* 	 创建好A半成品之后，逻辑继续往下
*
* 		1. addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
*
* =======================================================================================================
* 	三级缓存  |  创建 A 对象的时候，先往三级缓存中放了一个 lambda 表达式
* 	二级缓存  |																								(此时的缓存状态)
* 	一级缓存  |
* =======================================================================================================
*
* 		2. 给A对象中的属性赋值， 此时开始创建 B 对象，此时解析到 B 是一个 RunTimeBeanReference，
* 			然后开始创建B对象
*
* =======================================================================================================
	三级缓存  |  创建 A 对象的时候，往三级缓存中放了一个 lambda 表达式
 					创建 B 对象的时候，往三级缓存中放了一个 lambda 表达式
	二级缓存  |																								(此时的缓存状态)
	一级缓存  |
* =======================================================================================================
*
* 		3. 给 B 对象填充属性，发现是 A 的 RunTimeBeanReference，但是此时三级缓存中只是 A 和 B 的两个lambda表达式，
* 				缓存中没有任何跟 成品或者半成品有关的对象，所以在
*
* 				三级缓存中取找到对应的 lambda 表达式开始执行放进去的那个 lambda 表达式。
* 				如果没有配置AOP，则返回之前创建的 半成品对象、如果有 AOP 返回代理对象。
*
* 			此时取到 A 的半成品，放入二级缓存
* =======================================================================================================
 	三级缓存  |  创建 A 对象的时候，往三级缓存中放了一个 lambda 表达式
 					创建 B 对象的时候，往三级缓存中放了一个 lambda 表达式

 	二级缓存  |	A的半成品																							(此时的缓存状态)
 	一级缓存  |
* =======================================================================================================
*
* 		4.
* 		此时就可以给B赋值了，B创建了完成对象，添加到一级缓存，移除其他缓存中跟B有关的对象
*
* =======================================================================================================
	三级缓存  |  创建 A 对象的时候，往三级缓存中放了一个 lambda 表达式

	二级缓存  |	A的半成品																							(此时的缓存状态)
	一级缓存  |	B的成品
* =======================================================================================================
*
*		5.接下来就可以给 A 赋值 B属性了
*
*
*=======================================================================================================
*=======================================================================================================
*=======================================================================================================
*=======================================================================================================
*=======================================================================================================
*=======================================================================================================
*
* 三级缓存存在的意义：
* 	如果没有代理对象，那么直接使用一级二级缓存就足以解决循环依赖问题，如果有了AOP，而且不使用三级缓存，会有以下问题：
* 		（假设我们修改了源码，去掉一个三级缓存，半成品创建之后就放入二级缓存）
* 		1. A 创建，赋值 B属性
* 		2. B 创建， 赋值 A 属性
* 		3. 从二级缓存中 取到 A 的半成品给 B对象 中 A 属性赋值
* 		4. B 已经是一个完成的普通对象
* 		5. B 要在 BPP 的 after 方法中创建代理对象，代理对象创建之后引用的依然是 A 的普通对象
* 		6. CGLib_B 代理创建完毕，B对象彻底创建完毕，放入一级缓存
* 		7. 给 A 对象的 B 属性赋值，
* 		8. A 要在 BPP 的 after 方法中创建代理对象，A 引用的是 B的代理对象
* 		9. CGLib_A 代理对象创建完毕,引用 CGLib_B
* 			现在的引用关系是：
* 				CGLib_A --> CGLib_B
* 				CGLib_B --> 普通 A
* 		出问题了！！！
*
* 	三级缓存的意义就是，直接需要获取对象的时候直接生成代理对象。不在赋值结束之后再生成代理！
* 	通过一个 lambda 完美解决了问题
* */
